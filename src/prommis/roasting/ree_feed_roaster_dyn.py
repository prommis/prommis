#####################################################################################################
# “PrOMMiS” was produced under the DOE Process Optimization and Modeling for Minerals Sustainability
# (“PrOMMiS”) initiative, and is copyright (c) 2023-2025 by the software owners: The Regents of the
# University of California, through Lawrence Berkeley National Laboratory, et al. All rights reserved.
# Please see the files COPYRIGHT.md and LICENSE.md for full copyright and license information.
#####################################################################################################
r"""
IDAES REE Feed Roaster Unit Model
==================================

This model represents a roaster/calcination unit for Rare Earth Element (REE) feedstock, which includes rare earth minerals,
gangue/impurity minerals, moisture, and combustible organic materials containing :ce:`C`, :ce:`H`, :ce:`O`, :ce:`N`, and :ce:`S` elements.
This model can be used for both steady-state and dynamic simulations. Since the reaction kinetics are considered,
the reactor volume and the voidage of the reactor bed have to be specified and solid material holdup will be calculated
even for a steady-state simulation.

Reactions
---------

The reactions of impurities involved are listed below:

1. Kaolinite calcination:
   
   .. ce::
      Al2O3 \cdot 2SiO2 \cdot 2H2O -> Al2O3 + 2 SiO2 + 2 H2O (g)

   Typically occurs above 400°C. Complete conversion is assumed for this reaction.

2. Limestone calcination:

   .. ce::
      CaCO3 -> CaO + CO2 (g)

   Typically occurs above 850°C. Conversion is a determined by kinetics in the following reference:
   Carrillo Garcia, A. (2019). Thermal Decomposition of a Rare Earth Ore, Ph.D. thesis, Polytechnique Montréal.

3. Pyrite combustion:

   .. ce::
      FeS2 + 2.75 O2 -> 0.5 Fe2O3 + 2 SO2 (g)

   Typically occurs above 600°C. Complete conversion is assumed.

Combustion of organic elements is modeled as follows:

- :ce:`C + O2 -> CO2`
- :ce:`H + 0.25 O2 -> 0.5 H2O`
- :ce:`O -> 0.5 O2`
- :ce:`N -> 0.5 N2`
- :ce:`S + O2 -> SO2`

The reactions of insoluble rare earth mineral represented by :ce:`RE2X` to dissovable rare earth oxide :ce:`RE2O3` and
inert rare earth mineral (never leachable) :ce:`Ree2X` are through two parallel competing reactions.

   .. ce::
      RE2X -> y1 RE2O3 + (1-y1) Ree2X

   .. ce::
      RE2X -> y2 RE2O3 + (1-y2) Ree2X

   where :ce:`RE` represent an element including :ce:`Sc`, :ce:`Y`, :ce:`La`, :ce:`Ce`, :ce:`Pr`, :ce:`Nd`, :ce:`Sm`, :ce:`Gd`, and :ce:`Dy`.
   The first reaction has a lower activation energy and a higher oxide yield `y1`
   while the second reaction has a higher activation energy and a lower oxide yield `y2`.
   This reaction mechanism tends to predict low conversions to dissovable oxides at too low or too high reaction temperatures.


Physical Changes
----------------

Moisture in the feed stream is vaporized.

Solid Composition
----------------------

A property package named ReeFeedParameters should be used to represent the solid feed material.
Impurity minerals are assumed to be a mixture of :ce:`SiO2`, :ce:`Al2O3`, `kaolinite`, :ce:`CaCO3`, :ce:`CaO`, `pyrite` (:ce:`FeS2`),
and :ce:`Fe2O3`. The solid feed material also contains moisture and organic material including :ce:`C`, :ce:`H`, :ce:`O`,
:ce:`N`, :ce:`S` elements. The composition of the organic material is specified by the user.
The insoluble rare earth mineral is represented as RE2X in the ReeFeedParameters property package where RE stands for
a rare earth element. The dissovable rare earth mineral is represented as RE2O3 in the ReeFeedParameters property package
where RE stands for a rare earth element. After roasting, the solid product stream does not contain moisture and organic elements.
A property package named ReeRoastParameters is used to represent the solid product.

Heat Source
-----------

The heat to the reactor can be provided either by external heating as a user input or by the combustion of a fossil fuel with air to
form a hot :ce:`O2`-containing flue gas. The gas inlet stream is an :ce:`O2`-containing hot flue gas.
Due to the combustible organic contents in the solid feed stream, heat is usually generated by the combustion of the organic material.
However, hot gas is still required to start the combustion.

Streams
-------

- **Gas Inlet Stream**: :ce:`O2`-containing hot gas fed to the reactor. It must contain at least :ce:`O2`, :ce:`N2`, :ce:`H2O`,
:ce:`CO2`, and :ce:`SO2`. IDAES' generic ideal gas property package can be used for the gas stream.
- **Gas Outlet Stream**: Gas product leaving the reactor. The same gas property package as that for the gas inlet stream should be used.
- **Solid Inlet Stream**: Solid REE-containling material fed to the reactor. A property package of `ReeFeedParameters` should be used.
- **Solid Outlet Stream**: Solid product leaving the reactor without moisture and organic contents. A property package of
`ReeRoastParameters` should be used.
- **Leach Solid Outlet Stream**: Solid product leaving the reactor with species consistent with the leach solids property package
`CoalRefuseParameters`. This stream can be linked to the subsequent leaching unit.


Thermal Properties
------------------

The standard heats of formation and heat capacities of solid components involved are defined as parameters in this model.
The default values of those parameters are obtained from two sources as listed below:

1. NIST Chemistry WebBook
2. Wagman, D.D., W.H. Evans, V.B. Parker, R.H.Schumm, I. Halow, S.M. Bailey, K.L. Churney,
   R.L. Nuttall, "The NBS tables of chemical thermodynamic properties-Selected values for
   inorganic and C1 and C2 organic substances in SI units," Journal of Physical and Chemical
   Reference Data, 11(2), 1982

The NIST WebBook data are used for the properties of :ce:`Al2O3`, :ce:`SiO2`, :ce:`CaO`, :ce:`Fe2O3`, and `pyrite`. 
Note that the heat capacity model is simplified as a linear function of temperature.
The data of Wagman et al are used for the properties of :ce:`CaCO3` and `kaolinite`.
The gas phase properties are calculated based on user configured property package.
The heat capacity of organic part of the feed is usually a function of temperature and elemental composition of
:ce:`C`, :ce:`H`, :ce:`O`, :ce:`N`, and :ce:`S` elements according to Merrick (1983).
For simplicity, a constant heat capacity of 1260 J/kg-K in the range reported by Merrick is used in this model.
The standard enthalpy of formation of the organic material is assumed to be zero. In other words,
they are treated as elemental molecules, which may cause slightly overprediction of the heating value of the organic material.

Assumptions
-----------

- No kinetics or mass transfer is considered for the Kaolinite calcination and pyrite combustion. Complete conversions are assumed.
- Reaction rate for :ce:`CaCO3` calcination is based on kinetics reported by Carrillo Garcia (2019). 
The rate is a function of conversion. It is assumed that the conversion of :ce:`CaCO3` in the feed stream is zero.
- Reaction rates for the conversion of insoluble REE mineral to dissolvable mineral for each element is modeled by
two competing reactions with two different activation energies and yield fractions.
- The carryover of fine particles by the gas stream is ignored. The user should add a splitter model for the solid
product stream to account for the solid material loss due to the carryover.
- Rare earth minerals, being in ppm level, are ignored in energy balance. The property packages assume zero enthalpy and
heat capacity for them.
- If the product temperature is specified as a user input, the heat duty will be calculated. If the heat duty is given,
the product temperature will be calculated. Note that due to the contents of combustible organic elements,
the overall effect of the reactions is very likely exothermic even though calcination reactions are endothermic.
- Temperatures of solid and gas products are assumed to be the same.

"""

from pyomo.dae import DerivativeVar
from pyomo.environ import Block, Constraint, Param, Var, value, exp, sqrt, units
from pyomo.common.config import Bool, ConfigBlock, ConfigValue

from idaes import logger as idaeslog
from idaes.core import UnitModelBlockData, declare_process_block_class, useDefault
from idaes.core.initialization import ModularInitializerBase
from idaes.core.scaling import CustomScalerBase
from idaes.core.util.config import DefaultBool, is_physical_parameter_block
from idaes.core.util.constants import Constants as const


__author__ = "Jinliang Ma"
__version__ = "1.0.0"


class REEFeedRoasterScaler(CustomScalerBase):
    """
    Scaler for the REEFeedRoaster unit model.
    """

    DEFAULT_SCALING_FACTORS = {
        "volume": 1.0,
        "voidage": 1.0,
    }

    def variable_scaling_routine(
        self, model, overwrite: bool = False, submodel_scalers: dict = None
    ):
        """
        Variable scaling routine for REEFeedRoaster.

        Args:
            model: instance of REEFeedRoaster to be scaled
            overwrite: whether to overwrite existing scaling factors
            submodel_scalers: dict of Scalers to use for sub-models, keyed by submodel local name

        Returns:
            None
        """
        submodel_scalers_1 = {}
        if submodel_scalers is not None:
            submodel_scalers_1 = submodel_scalers

        # scaling property submodel variables
        # gas inlet properties
        self.call_submodel_scaler_method(
            submodel=model.gas_in,
            submodel_scalers=submodel_scalers_1,
            method="variable_scaling_routine",
            overwrite=overwrite,
        )
        # gas outlet properties
        self.call_submodel_scaler_method(
            submodel=model.gas_out,
            submodel_scalers=submodel_scalers_1,
            method="variable_scaling_routine",
            overwrite=overwrite,
        )
        # solid inlet properties
        self.call_submodel_scaler_method(
            submodel=model.solid_in,
            submodel_scalers=submodel_scalers_1,
            method="variable_scaling_routine",
            overwrite=overwrite,
        )
        # solid outlet properties
        self.call_submodel_scaler_method(
            submodel=model.solid_out,
            submodel_scalers=submodel_scalers_1,
            method="variable_scaling_routine",
            overwrite=overwrite,
        )
        # leach solid outlet properties
        self.call_submodel_scaler_method(
            submodel=model.leach_solid_out,
            submodel_scalers=submodel_scalers_1,
            method="variable_scaling_routine",
            overwrite=overwrite,
        )

        if hasattr(model, "volume"):
            self.scale_variable_by_default(model.volume, overwrite=overwrite)
        if hasattr(model, "voidage"):
            self.scale_variable_by_default(model.voidage, overwrite=overwrite)

        if hasattr(model, "heat_duty"):
            for v in model.heat_duty.values():
                sf = 1e-6
                self.set_variable_scaling_factor(v, sf, overwrite=overwrite)
        if hasattr(model, "deltaP"):
            for v in model.deltaP.values():
                sf = 1e-3
                self.set_variable_scaling_factor(v, sf, overwrite=overwrite)

        for (t, i), v in model.solid_material_holdup.items():
            sf_volume = self.get_scaling_factor(model.volume)
            sf_voidage = self.get_scaling_factor(model.voidage)
            sf_mf = self.get_scaling_factor(model.solid_out[t].mass_frac_comp[i])
            sf = (
                sf_volume
                * sf_voidage
                * sf_mf
                / value(model.config.solid_product_property_package.dens_mass)
                * value(model.config.solid_product_property_package.mw_comp[i])
            )
            self.set_variable_scaling_factor(v, sf, overwrite=overwrite)

        if hasattr(model, "solid_energy_holdup"):
            for t, v in model.solid_energy_holdup.items():
                sf = (
                    self.get_scaling_factor(model.volume)
                    * self.get_scaling_factor(model.voidage)
                    / value(model.config.solid_product_property_package.dens_mass)
                    * self.get_scaling_factor(model.solid_out[t].enth_mass)
                )
                self.set_variable_scaling_factor(v, sf, overwrite=overwrite)

        if hasattr(model, "solid_material_accumulation"):
            for (t, i), v in model.solid_material_accumulation.items():
                if i in ["Al2O3", "SiO2", "CaCO3", "CaO", "Fe2O3"]:
                    sf = 1e3
                else:
                    sf = 1e6
                self.set_variable_scaling_factor(v, sf, overwrite=overwrite)

        if hasattr(model, "solid_energy_accumulation"):
            for v in model.solid_energy_accumulation.values():
                sf = 1e-4
                self.set_variable_scaling_factor(v, sf, overwrite=overwrite)

        for v in model.rate_CaCO3.values():
            sf = 20
            self.set_variable_scaling_factor(v, sf, overwrite=overwrite)

        for (t, i), v in model.rate_REE1.items():
            sf = 1e5
            self.set_variable_scaling_factor(v, sf, overwrite=overwrite)

        for (t, i), v in model.rate_REE2.items():
            sf = 1e7
            self.set_variable_scaling_factor(v, sf, overwrite=overwrite)

    def constraint_scaling_routine(
        self, model, overwrite: bool = False, submodel_scalers: dict = None
    ):
        """
        Routine to apply scaling factors to constraints in model.

        Args:
            model: model to be scaled
            overwrite: whether to overwrite existing scaling factors
            submodel_scalers: dict of Scalers to use for sub-models, keyed by submodel local name

        Returns:
            None
        """

        self.call_submodel_scaler_method(
            submodel=model.gas_in,
            submodel_scalers=submodel_scalers,
            method="constraint_scaling_routine",
            overwrite=overwrite,
        )
        self.call_submodel_scaler_method(
            submodel=model.gas_out,
            submodel_scalers=submodel_scalers,
            method="constraint_scaling_routine",
            overwrite=overwrite,
        )
        self.call_submodel_scaler_method(
            submodel=model.solid_in,
            submodel_scalers=submodel_scalers,
            method="constraint_scaling_routine",
            overwrite=overwrite,
        )
        self.call_submodel_scaler_method(
            submodel=model.solid_out,
            submodel_scalers=submodel_scalers,
            method="constraint_scaling_routine",
            overwrite=overwrite,
        )
        self.call_submodel_scaler_method(
            submodel=model.leach_solid_out,
            submodel_scalers=submodel_scalers,
            method="constraint_scaling_routine",
            overwrite=overwrite,
        )

        for idx, con in model.solid_material_holdup_eqn.items():
            t, i = idx
            sf = self.get_scaling_factor(model.solid_material_holdup[t, i])
            self.set_constraint_scaling_factor(con, sf, overwrite=overwrite)

        if hasattr(model, "solid_energy_holdup_eqn"):
            for t, con in model.solid_energy_holdup_eqn.items():
                sf = self.get_scaling_factor(model.solid_energy_holdup[t])
                self.set_constraint_scaling_factor(con, sf, overwrite=overwrite)

        for t, con in model.rate_CaCO3_eqn.items():
            sf = self.get_scaling_factor(model.rate_CaCO3[t])
            self.set_constraint_scaling_factor(con, sf, overwrite=overwrite)

        for (t, i), con in model.rate_REE1_eqn.items():
            sf = self.get_scaling_factor(model.rate_REE1[t, i])
            self.set_constraint_scaling_factor(con, sf, overwrite=overwrite)

        for (t, i), con in model.rate_REE2_eqn.items():
            sf = self.get_scaling_factor(model.rate_REE2[t, i])
            self.set_constraint_scaling_factor(con, sf, overwrite=overwrite)

        for (t, i), con in model.solid_mass_balance_eqn.items():
            sf = self.get_scaling_factor(model.solid_out[t].flow_mol_comp[i])
            self.set_constraint_scaling_factor(con, sf, overwrite=overwrite)

        for (t, i), con in model.gas_mass_balance_eqn.items():
            sf = 1.0  # self.get_scaling_factor(model.gas_out[t].flow_mol_comp[i])
            self.set_constraint_scaling_factor(con, sf, overwrite=overwrite)

        for (t, i), con in model.leach_solid_outlet_comp_eqn.items():
            sf = self.get_scaling_factor(model.solid_out[t].mass_frac_comp[i])
            self.set_constraint_scaling_factor(con, sf, overwrite=overwrite)

        for t, con in model.leach_solid_outlet_total_mass_flow_eqn.items():
            sf = self.get_scaling_factor(model.solid_out[t].flow_mass)
            self.set_constraint_scaling_factor(con, sf, overwrite=overwrite)

        for t, con in model.outlet_temperature_eqn.items():
            sf = self.get_scaling_factor(model.solid_out[t].temperature)
            self.set_constraint_scaling_factor(con, sf, overwrite=overwrite)

        for t, con in model.energy_balance_eqn.items():
            sf = 1e-6
            if hasattr(model, "heat_duty"):
                sf = self.get_scaling_factor(model.heat_duty[t])
            self.set_constraint_scaling_factor(con, sf, overwrite=overwrite)

        for t, con in model.momentum_balance_eqn.items():
            sf = 1e-5
            self.set_constraint_scaling_factor(con, sf, overwrite=overwrite)


class REEFeedRoasterInitializer(ModularInitializerBase):
    """
    This is a general purpose Initializer  for the REEFeedRoaster unit model.

    """

    def initialization_routine(
        self,
        model: Block,
    ):
        """
        Initialization routine for REEFeedRoaster Blocks.

        Args:
            model: model to be initialized

        Returns:
            None
        """

        init_log = idaeslog.getInitLogger(
            model.name, self.get_output_level(), tag="unit"
        )
        solve_log = idaeslog.getSolveLogger(
            model.name, self.get_output_level(), tag="unit"
        )

        # set the gas_out state variables the same as the gas_in state variables
        for i in model.config.gas_property_package.component_list:
            model.gas_out[:].mole_frac_comp[i].value = (
                model.gas_in[0].mole_frac_comp[i].value
            )
        model.gas_out[:].temperature.value = model.gas_in[0].temperature.value
        model.gas_out[:].pressure.value = model.gas_in[0].pressure.value
        model.gas_out[:].flow_mol.value = model.gas_in[0].flow_mol.value

        model.rate_CaCO3.fix(0)
        model.rate_REE1.fix(0)
        model.rate_REE2.fix(0)
        for i in model.config.leach_solids_property_package.component_list:
            model.leach_solid_out[:].mass_frac_comp[i].fix(
                model.config.leach_solids_property_package.mass_frac_comp_initial[i]
            )
        model.leach_solid_out[:].mass_frac_comp["inerts"].unfix()
        model.leach_solid_out[:].flow_mass.fix(model.solid_in[0].flow_mass.value * 0.8)
        model.rate_CaCO3_eqn.deactivate()
        model.rate_REE1_eqn.deactivate()
        model.rate_REE2_eqn.deactivate()
        model.leach_solid_outlet_comp_eqn.deactivate()
        model.leach_solid_outlet_total_mass_flow_eqn.deactivate()
        solver = self._get_solver()
        with idaeslog.solver_log(solve_log, idaeslog.DEBUG) as slc:
            res = solver.solve(model, tee=slc.tee)
        init_log.info_high("Initialization Step 1 {}.".format(idaeslog.condition(res)))
        model.rate_CaCO3.unfix()
        model.rate_REE1.unfix()
        model.rate_REE2.unfix()
        model.leach_solid_out[:].mass_frac_comp[:].unfix()
        model.leach_solid_out[:].flow_mass.unfix()
        model.rate_CaCO3_eqn.activate()
        model.rate_REE1_eqn.activate()
        model.rate_REE2_eqn.activate()
        model.leach_solid_outlet_comp_eqn.activate()
        model.leach_solid_outlet_total_mass_flow_eqn.activate()
        with idaeslog.solver_log(solve_log, idaeslog.DEBUG) as slc:
            res = solver.solve(model, tee=slc.tee)
        init_log.info("Initialization Complete.")

        return res


# ----------------------------------------------------------------------------------------------------------
@declare_process_block_class("REEFeedRoaster")
class REEFeedRoasterData(UnitModelBlockData):
    """
    Simple 0D roaster model with mass and energy balance only
    """

    CONFIG = ConfigBlock()
    CONFIG.declare(
        "dynamic",
        ConfigValue(
            domain=DefaultBool,
            default=useDefault,
            description="Dynamic model flag",
            doc="""Indicates whether this model will be dynamic or not,
**default** = useDefault.
**Valid values:** {
**useDefault** - get flag from parent (default = False),
**True** - set as dynamic model,
**False** - set as a steady-state model.}""",
        ),
    )
    CONFIG.declare(
        "has_holdup",
        ConfigValue(
            default=True,
            domain=Bool,
            description="Holdup construction flag",
            doc="""Indicates whether holdup terms should be constructed or not.
Must be True if dynamic = True,
**default** - False.
**Valid values:** {
**True** - construct holdup terms,
**False** - do not construct holdup terms}""",
        ),
    )
    CONFIG.declare(
        "gas_property_package",
        ConfigValue(
            default=useDefault,
            domain=is_physical_parameter_block,
            description="Property package to use for control volume",
            doc="""Property parameter object used to define property calculations,
**default** - useDefault.
**Valid values:** {
**useDefault** - use default package from parent model or flowsheet,
**PhysicalParameterObject** - a PhysicalParameterBlock object.}""",
        ),
    )
    CONFIG.declare(
        "gas_property_package_args",
        ConfigBlock(
            implicit=True,
            description="Arguments to use for constructing property packages",
            doc="""A ConfigBlock with arguments to be passed to a property block(s)
and used when constructing these,
**default** - None.
**Valid values:** {
see property package for documentation.}""",
        ),
    )
    CONFIG.declare(
        "solid_feed_property_package",
        ConfigValue(
            default=useDefault,
            domain=is_physical_parameter_block,
            description="Property package to use for control volume",
            doc="""Property parameter object used to define property calculations,
**default** - useDefault.
**Valid values:** {
**useDefault** - use default package from parent model or flowsheet,
**PhysicalParameterObject** - a PhysicalParameterBlock object.}""",
        ),
    )
    CONFIG.declare(
        "solid_feed_property_package_args",
        ConfigBlock(
            implicit=True,
            description="Arguments to use for constructing property packages",
            doc="""A ConfigBlock with arguments to be passed to a property block(s)
and used when constructing these,
**default** - None.
**Valid values:** {
see property package for documentation.}""",
        ),
    )
    CONFIG.declare(
        "solid_product_property_package",
        ConfigValue(
            default=useDefault,
            domain=is_physical_parameter_block,
            description="Property package to use for control volume",
            doc="""Property parameter object used to define property calculations,
**default** - useDefault.
**Valid values:** {
**useDefault** - use default package from parent model or flowsheet,
**PhysicalParameterObject** - a PhysicalParameterBlock object.}""",
        ),
    )
    CONFIG.declare(
        "solid_product_property_package_args",
        ConfigBlock(
            implicit=True,
            description="Arguments to use for constructing property packages",
            doc="""A ConfigBlock with arguments to be passed to a property block(s)
and used when constructing these,
**default** - None.
**Valid values:** {
see property package for documentation.}""",
        ),
    )
    CONFIG.declare(
        "leach_solids_property_package",
        ConfigValue(
            default=useDefault,
            domain=is_physical_parameter_block,
            description="Property package to use for control volume",
            doc="""Property parameter object used to define property calculations,
**default** - useDefault.
**Valid values:** {
**useDefault** - use default package from parent model or flowsheet,
**PhysicalParameterObject** - a PhysicalParameterBlock object.}""",
        ),
    )
    CONFIG.declare(
        "leach_solids_property_package_args",
        ConfigBlock(
            implicit=True,
            description="Arguments to use for constructing property packages",
            doc="""A ConfigBlock with arguments to be passed to a property block(s)
and used when constructing these,
**default** - None.
**Valid values:** {
see property package for documentation.}""",
        ),
    )
    CONFIG.declare(
        "has_heat_transfer",
        ConfigValue(
            default=False,
            domain=Bool,
            description="Heat transfer term construction flag",
            doc="""Indicates whether terms for heat transfer should be constructed,
**default** - False.
**Valid values:** {
**True** - include heat transfer terms,
**False** - exclude heat transfer terms.}""",
        ),
    )
    CONFIG.declare(
        "has_pressure_change",
        ConfigValue(
            default=False,
            domain=Bool,
            description="Pressure change term construction flag",
            doc="""Indicates whether terms for pressure change should be
constructed,
**default** - False.
**Valid values:** {
**True** - include pressure change terms,
**False** - exclude pressure change terms.}""",
        ),
    )

    def build(self):
        # Call TranslatorData build to setup dynamics
        super(REEFeedRoasterData, self).build()

        # Build inlet and outlet state blocks
        # gas phase inlet stream
        self.gas_in = self.config.gas_property_package.build_state_block(
            self.flowsheet().time,
            defined_state=True,
            **self.config.gas_property_package_args
        )
        # gas phase outlet stream
        self.gas_out = self.config.gas_property_package.build_state_block(
            self.flowsheet().time, **self.config.gas_property_package_args
        )
        # solid phase inlet stream

        self.solid_in = self.config.solid_feed_property_package.build_state_block(
            self.flowsheet().time,
            defined_state=True,
            **self.config.solid_feed_property_package_args
        )

        # solid phase product stream
        self.solid_out = self.config.solid_product_property_package.build_state_block(
            self.flowsheet().time, **self.config.solid_product_property_package_args
        )

        # leach solid product stream
        self.leach_solid_out = (
            self.config.leach_solids_property_package.build_state_block(
                self.flowsheet().time, **self.config.leach_solids_property_package_args
            )
        )

        self.add_port("gas_inlet", self.gas_in)
        self.add_port("gas_outlet", self.gas_out)
        self.add_port("solid_inlet", self.solid_in)
        self.add_port("solid_outlet", self.solid_out)
        self.add_port("leach_solid_outlet", self.leach_solid_out)

        # Add Geometry
        # This model always has a volume for reaction rate calculation
        # In other words, there is always a material holdup
        # Currently the gas phase material and energy holdup are ignored even for dynamic model
        # The energy holdup is needed only for dynamic cases

        self.volume = Var(initialize=1, units=units.m**3, doc="volume of the reactor")

        self.voidage = Var(
            initialize=0.4,
            doc="Void fraction of the reactor bed. The fraction occupied by the gas phase",
        )

        @self.Expression(doc="Volume of solid phase")
        def volume_solid(b):
            return b.volume * (1 - b.voidage)

        # Add heat duty
        if self.config.has_heat_transfer is True:
            self.heat_duty = Var(
                self.flowsheet().time,
                initialize=0,
                units=units.W,
                doc="heat duty added to the reactor",
            )

        if self.config.has_pressure_change is True:
            self.deltaP = Var(
                self.flowsheet().time,
                initialize=0,
                units=units.Pa,
                doc="pressure drop from inlet to outlet",
            )

        self.Ree_list = ["Sc", "Y", "La", "Ce", "Pr", "Nd", "Sm", "Gd", "Dy"]
        self.Ree_Ins_lookup = {
            "Sc": "Sc2X",
            "Y": "Y2X",
            "La": "La2X",
            "Ce": "Ce2X",
            "Pr": "Pr2X",
            "Nd": "Nd2X",
            "Sm": "Sm2X",
            "Gd": "Gd2X",
            "Dy": "Dy2X",
        }

        # Construct performance equations
        self._make_params()
        self._make_vars()
        self._make_mass_balance()
        self._make_energy_balance()
        self._make_momentum_balance()

    def _make_params(self):
        self.A_CaCO3 = Param(
            initialize=exp(23.5),
            mutable=True,
            units=1 / units.s,
            doc="Pre-exponential factor for CaCO3 decomposition",
        )

        # Kinetic parameter and model format based on Adrian Carrillo Garcia,
        # "Thermal Decomposition of a Rare Earth Ore", PhD Dissertation, Polytechnique Montréal, 2019
        self.E_CaCO3 = Param(
            initialize=2.094e5,
            mutable=True,
            units=units.J / units.mol,
            doc="Activation energy for CaCO3 decomposition",
        )

        self.A_REE1 = Param(
            self.Ree_list,
            initialize=23.7,
            mutable=True,
            units=1 / units.s,
            doc="Pre-exponential factor for the first REE roasting reaction",
        )

        self.A_REE2 = Param(
            self.Ree_list,
            initialize=3.6e7,
            mutable=True,
            units=1 / units.s,
            doc="Pre-exponential factor for the 2nd REE roasting reaction",
        )

        self.E_REE1 = Param(
            self.Ree_list,
            initialize=75980.0,
            mutable=True,
            units=units.J / units.mol,
            doc="Activation energy for the 1st REE roasting reaction",
        )

        self.E_REE2 = Param(
            self.Ree_list,
            initialize=203339.3,
            mutable=True,
            units=units.J / units.mol,
            doc="Activation energy for the 2nd REE roasting reaction",
        )

        self.y_REE1 = Param(
            self.Ree_list,
            initialize=0.375 * 2,
            mutable=True,
            doc="Fraction of dissolvable REE product after roasting for the 1st reaction",
        )

        self.y_REE2 = Param(
            self.Ree_list,
            initialize=9.31e-5 * 2,
            mutable=True,
            doc="Fraction of dissolvable REE product after roasting for the 2nd reaction",
        )

    def _make_vars(self):
        """This section declares variables within this model."""
        self.solid_material_holdup = Var(
            self.flowsheet().time,
            self.config.solid_product_property_package.component_list,
            initialize=1.0,
            bounds=(1e-10, None),
            units=units.mol,
            doc="Solid species mole holdup",
        )

        if self.config.dynamic:
            self.solid_energy_holdup = Var(
                self.flowsheet().time,
                initialize=1.0,
                units=units.J,
                doc="Solid energy holdup",
            )

            self.solid_material_accumulation = DerivativeVar(
                self.solid_material_holdup,
                wrt=self.flowsheet().config.time,
                units=units.mol / units.s,
                doc="Accumulation of solid material",
            )

            self.solid_energy_accumulation = DerivativeVar(
                self.solid_energy_holdup,
                wrt=self.flowsheet().config.time,
                units=units.W,
                doc="Solid energy accumulation",
            )

        self.rate_CaCO3 = Var(
            self.flowsheet().config.time,
            initialize=1.0,
            units=units.mol / units.s,
            doc="Rate of CaCO3 decomposition, Always positive",
        )

        self.rate_REE1 = Var(
            self.flowsheet().config.time,
            self.Ree_list,
            initialize=1.0,
            units=units.mol / units.s,
            doc="Rate of 1st REE roasting reaction in term of mole of reactant reacted, Always positive",
        )

        self.rate_REE2 = Var(
            self.flowsheet().config.time,
            self.Ree_list,
            initialize=1.0,
            units=units.mol / units.s,
            doc="Rate of 2nd REE roasting reaction in term of mole of reactant reacted, Always positive",
        )

    def _make_mass_balance(self):
        """This section contains equations for mass balance within the reactor model."""

        @self.Expression(
            self.flowsheet().config.time,
            doc="Mole fraction of original CaCO3 between CaCO3 and CaO in feed stream",
        )
        def mole_fraction_of_ca_as_caco3_in_feed(b, t):
            return (
                b.solid_in[t].mass_frac_comp["CaCO3"]
                / b.config.solid_feed_property_package.mw_comp["CaCO3"]
                / (
                    b.solid_in[t].mass_frac_comp["CaCO3"]
                    / b.config.solid_feed_property_package.mw_comp["CaCO3"]
                    + b.solid_in[t].mass_frac_comp["CaO"]
                    / b.config.solid_feed_property_package.mw_comp["CaO"]
                )
            )

        # Holdup calculations
        @self.Constraint(
            self.flowsheet().config.time,
            self.config.solid_product_property_package.component_list,
            doc="Solid material holdup",
        )
        def solid_material_holdup_eqn(b, t, i):
            return (
                b.solid_material_holdup[t, i]
                == b.volume_solid
                * self.config.solid_product_property_package.dens_mass
                * b.solid_out[t].mass_frac_comp[i]
                / self.config.solid_product_property_package.mw_comp[i]
            )

        if self.config.dynamic:

            @self.Constraint(
                self.flowsheet().config.time,
                doc="Solid internal energy holdup",
            )
            def solid_energy_holdup_eqn(b, t):
                return (
                    b.solid_energy_holdup[t]
                    == b.volume_solid
                    * self.config.solid_product_property_package.dens_mass
                    * b.solid_out[t].enth_mass
                )

        @self.Constraint(
            self.flowsheet().config.time,
            doc="CaCO3 decomposition rate",
        )
        def rate_CaCO3_eqn(b, t):
            return b.rate_CaCO3[t] == 2 * sqrt(
                b.solid_material_holdup[t, "CaCO3"]
                * (
                    b.solid_material_holdup[t, "CaCO3"]
                    + b.solid_material_holdup[t, "CaO"]
                )
            ) * b.A_CaCO3 * exp(
                -b.E_CaCO3 / const.gas_constant / b.solid_out[t].temperature
            )

        @self.Constraint(
            self.flowsheet().config.time,
            self.Ree_list,
            doc="Rate of the 1st roasting reaction",
        )
        def rate_REE1_eqn(b, t, i):
            j = b.Ree_Ins_lookup[i]
            return b.rate_REE1[t, i] == b.solid_material_holdup[t, j] * b.A_REE1[
                i
            ] * exp(-b.E_REE1[i] / const.gas_constant / b.solid_out[t].temperature)

        @self.Constraint(
            self.flowsheet().config.time,
            self.Ree_list,
            doc="Rate of the 2nd roasting reaction",
        )
        def rate_REE2_eqn(b, t, i):
            j = b.Ree_Ins_lookup[i]
            return b.rate_REE2[t, i] == b.solid_material_holdup[t, j] * b.A_REE2[
                i
            ] * exp(-b.E_REE2[i] / const.gas_constant / b.solid_out[t].temperature)

        # solid phase mass balance equation
        @self.Constraint(
            self.flowsheet().config.time,
            self.config.solid_product_property_package.component_list,
            doc="Species material balance for the solid phase",
        )
        def solid_mass_balance_eqn(b, t, i):
            if self.config.dynamic:
                accumulation = b.solid_material_accumulation[t, i]
            else:
                accumulation = 0 * units.mol / units.s
            if i == "Al2O3":
                # Kaolinite -> Al2O3 + 2 SiO2 + 2 H2O (g)
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.solid_in[t].flow_mol_comp["Kaolinite"]
                )
            elif i == "SiO2":
                # Kaolinite -> Al2O3 + 2 SiO2 + 2 H2O (g)
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.solid_in[t].flow_mol_comp["Kaolinite"] * 2
                )
            elif i == "CaCO3":
                # CaCO3 -> CaO + CO2 (g)
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    - b.rate_CaCO3[t]
                )
            elif i == "CaO":
                # CaCO3 -> CaO + CO2 (g)
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.rate_CaCO3[t]
                )
            elif i == "Fe2O3":
                # FeS2 + 2.75O2 (g) -> 0.5Fe2O3 + 2SO2 (g)
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + 0.5 * b.solid_in[t].flow_mol_comp["FeS2"]
                )
            elif i == "Ree2X":
                # RE2X -> yRE2O3 + (1-y)Ree2X with O2 reactant ignored
                return accumulation == b.solid_in[t].flow_mol_comp[i] - b.solid_out[
                    t
                ].flow_mol_comp[i] + sum(
                    (1 - b.y_REE1[j]) * b.rate_REE1[t, j]
                    + (1 - b.y_REE2[j]) * b.rate_REE2[t, j]
                    for j in b.Ree_list
                )
            elif i == "Y2X":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    - b.rate_REE1[t, "Y"]
                    - b.rate_REE2[t, "Y"]
                )
            elif i == "Y2O3":
                return (
                    accumulation
                    == b.solid_in[t].flow_mol_comp[i]
                    - b.solid_out[t].flow_mol_comp[i]
                    + b.y_REE1["Y"] * b.rate_REE1[t, "Y"]
                    + b.y_REE2["Y"] * b.rate_REE2[t, "Y"]
                )
            else:  # i is either RE2X or RE2O3
                j = i[0:2]
                k = i[3:]
                if k == "X":
                    return (
                        accumulation
                        == b.solid_in[t].flow_mol_comp[i]
                        - b.solid_out[t].flow_mol_comp[i]
                        - b.rate_REE1[t, j]
                        - b.rate_REE2[t, j]
                    )
                else:  # k == "O3"
                    return (
                        accumulation
                        == b.solid_in[t].flow_mol_comp[i]
                        - b.solid_out[t].flow_mol_comp[i]
                        + b.y_REE1[j] * b.rate_REE1[t, j]
                        + b.y_REE2[j] * b.rate_REE2[t, j]
                    )

        # the gas product should contain at least N2, O2, H2O, CO2, and SO2
        # assume no accumulation in the gas phase
        @self.Constraint(
            self.flowsheet().config.time,
            self.config.gas_property_package.component_list,
            doc="Gas phase species mass balance",
        )
        def gas_mass_balance_eqn(b, t, i):
            if i == "N2":
                return (
                    b.gas_out[t].flow_mol_comp[i]
                    == b.gas_in[t].flow_mol_comp[i]
                    + b.solid_in[t].flow_mol_comp["N"] / 2
                )
            elif i == "O2":
                return (
                    b.gas_out[t].flow_mol_comp[i]
                    == b.gas_in[t].flow_mol_comp[i]
                    + b.solid_in[t].flow_mol_comp["O"] / 2
                    - b.solid_in[t].flow_mol_comp["C"]
                    - b.solid_in[t].flow_mol_comp["S"]
                    - b.solid_in[t].flow_mol_comp["H"] / 4
                    - b.solid_in[t].flow_mol_comp["FeS2"] * 2.75
                )
            elif i == "H2O":
                return (
                    b.gas_out[t].flow_mol_comp[i]
                    == b.gas_in[t].flow_mol_comp[i]
                    + b.solid_in[t].flow_mol_comp["H"] / 2
                    + b.solid_in[t].flow_mol_comp["Kaolinite"] * 2
                    + b.solid_in[t].flow_mol_comp["H2O"]
                )
            elif i == "CO2":
                return (
                    b.gas_out[t].flow_mol_comp[i]
                    == b.gas_in[t].flow_mol_comp[i]
                    + b.solid_in[t].flow_mol_comp["C"]
                    + b.rate_CaCO3[t]
                )
            elif i == "SO2":
                return (
                    b.gas_out[t].flow_mol_comp[i]
                    == b.gas_in[t].flow_mol_comp[i]
                    + b.solid_in[t].flow_mol_comp["S"]
                    + b.solid_in[t].flow_mol_comp["FeS2"] * 2
                )
            else:
                return b.gas_out[t].flow_mol_comp[i] == b.gas_in[t].flow_mol_comp[i]

        # leach solid outlet stream, let the inert mass fraction calculated by sum = 1
        @self.Constraint(
            self.flowsheet().config.time,
            self.config.solid_product_property_package.component_list,
            doc="component flow of outlet solid stream",
        )
        def leach_solid_outlet_comp_eqn(b, t, i):
            if i in b.config.leach_solids_property_package.component_list:
                return (
                    b.leach_solid_out[t].mass_frac_comp[i]
                    == b.solid_out[t].mass_frac_comp[i]
                )
            else:
                return Constraint.Skip

        @self.Constraint(
            self.flowsheet().config.time,
            doc="Total mass flow of leach solid out stream",
        )
        def leach_solid_outlet_total_mass_flow_eqn(b, t):
            return (
                units.convert(
                    b.leach_solid_out[t].flow_mass,
                    to_units=units.kg / units.s,
                )
                == b.solid_out[t].flow_mass
            )

    def _make_energy_balance(self):
        @self.Constraint(
            self.flowsheet().config.time,
            doc="Same gas and solid temperature constraint",
        )
        def outlet_temperature_eqn(b, t):
            return b.gas_out[t].temperature == b.solid_out[t].temperature

        # enthalpy in + heat in == enthalpy out
        @self.Constraint(
            self.flowsheet().config.time,
            doc="enthalpy balance equation for both phases",
        )
        def energy_balance_eqn(b, t):
            heat = 0 * units.W
            if self.config.has_heat_transfer is True:
                heat = b.heat_duty[t]
            if self.config.dynamic:
                accumulation = b.solid_energy_accumulation[t]
            else:
                accumulation = 0 * units.W
            return (
                accumulation
                == b.solid_in[t].enth_mass * b.solid_in[t].flow_mass
                + b.gas_in[t].enth_mol * b.gas_in[t].flow_mol
                - b.solid_out[t].enth_mass * b.solid_out[t].flow_mass
                - b.gas_out[t].enth_mol * b.gas_out[t].flow_mol
                + heat
            )

    def _make_momentum_balance(self):
        @self.Constraint(self.flowsheet().config.time, doc="momentum balance equation")
        def momentum_balance_eqn(b, t):
            if self.config.has_pressure_change is True:
                return b.gas_out[t].pressure == b.gas_in[t].pressure + b.deltaP[t]
            else:
                return b.gas_out[t].pressure == b.gas_in[t].pressure

    def set_initial_condition(self):
        if self.config.dynamic:
            t0 = self.flowsheet().time.first()
            self.solid_material_accumulation[:, :].value = 0
            self.solid_material_accumulation[t0, :].fix(0)
            self.solid_energy_accumulation[:].value = 0
            self.solid_energy_accumulation[t0].fix(0)
